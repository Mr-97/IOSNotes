iOS线程管理笔记
=============

iOS有三种多线程编程技术，分别是：

1、NSThread

2、Cocoa Operation

3、GCD (Grand Central Dispatch)

以上三种编程方式从上到下，抽象层次从低到高，抽象度越高的使用越简单，也是Apple最推荐使用的。

1、NSThread
-----------

优点：最轻量级

缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销。

### 1.1 调用方法如下：

1.1.1 类方法: 

	[NSThread detachNewThreadSelector:@selector(threadMethod:) toTarget:self withObject:argument];

1.1.2 实例方法: 

	NSThread *aThread = [[NSThread alloc] initWithTarget:self selector:@selector(threadMethod:) object:argument];
	[aThread start];

1.1.3 NSObject的类方法: 

	[obj performSelectorInBackground:@selector(threadMethod:) withObject:argument];

### 1.2 线程间通讯

1.2.1 与主线程通讯，更新界面

	[self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]

1.2.2 与其他线程通讯

	[self performSelector:@selector(threadMethod:) onThread:aThread withObject:argument waitUntilDone:YES];

### 1.3 线程同步

暂时省略

2、Cocoa Operation
------------------

优点：不需要关心线程管理，数据同步的事情，可以把经历放在自己需要执行的操作上。
Cocoa operation 相关的类是NSOperation、 NSOperationQueue。NSOperation是个抽象类，使用它必须用它的子类，可以实现它或者使用它定义好的两个子类:NSInvocationOperation 和 NSBlockOperation。创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。

### 2.1 示例：

	NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(operationMethod:) object:argument];
	    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
	    [queue setMaxConcurrentOperationCount:5]; // 设置线程池中线程数；默认值是-1，-1表示没有限制，这样会同时运行队列中的全部操作
	    [queue addOperation:operation];

### 2.2 继承NSOperation

继承NSOperation需要在.m文件中实现main方法，main方法中编写要执行的代码。

继承示例：

2.2.1 h文件中声名

	@interface ImageLoadingOperation : NSOperation
	{
	    NSURL *imageURL; // 图片地址
	    id target;       // 由于需要返回一些值，所以需要一个对象参数返回被返回的对象（运行此线程的类对象）
	    SEL action;      // 返回值要激发的方法函数
	}

	- (id)initWithImageURL:(NSURL *)theImageURL target:(id)theTarget action:(SEL)theAction;

2.2.2 m文件中实现

	- (id)initWithImageURL:(NSURL *)theImageURL target:(id)theTarget action:(SEL)theAction
	{
	    self = [super init];
	    if (self) {
	        imageURL = [theImageURL retain];
	        target = theTarget;
	        action = theAction;
	    }
	    return self;
	}

	- (void)main
	{
	    @autoreleasepool {
	        NSData *data = [[NSData alloc] initWithContentsOfURL:imageURL];
	        UIImage *image = [[UIImage alloc] initWithData:data];
	        
	        if (self.isCancelled) {
	            //
	        }
	        
	        // 打包返回给初始类对象，然后执行其指定的操作
	        NSDictionary *result = [NSDictionary dictionaryWithObjectsAndKeys:imageURL, ImageResultKey, imageURL, URLResultKey, nil];
	        [target performSelectorOnMainThread:action withObject:result waitUntilDone:NO];
	        
	        [data release];
	        [image release];
	        
	    }
	}

一般情况下不重写开始(start)方法，因为里面涉及到多种属性和状态的判断。当将一个操作添加到一个队列中时，这个队列会在操作(NSOperation实例)中调用"start"方法，然后它会做一些准备和"main"方法的后续操作。假如NSOperation实例中调用了"start"方法，如果没有把它添加到一个队列中，这个操作会在main loop中执行。

重写“start“方法就必须处理isExecuting, isFinished, isConcurrent和isReady这些属性。否则你的操作类就不会正确的运行。

一旦将一个线程加入队列（NSOperationQueue的一个实例）中，就要负责释放它（如果你不适用ARC的话）。NSOperationQueue获得操作对象的所有权，调用”start“方法，然后结束时负责释放它。

线程的实例化对象不能重用，一旦被添加金队列中，就丧失了对他的所有权。如果想再次使用同一个线程类，就必须长久安一个新的实例变量。结束的线程不能被重启。

如果一个操作被取消，它并不会立刻取消，而时在未来的某个时候某人在”main“函数中明确的检查isCanceled == YES时被取消掉。否则，操作会一直执行到完成为止。

一个操作是否成功的完成、失败，或者时被取消，isFinished的值总会被设置为YES。所以千万不要觉得isFinished == YES就表示所有的事情都顺利完成了-特别的，如果你在代码里面有从属性（dependencies），就要更加注意！

### 2.3 设置

2.3.1 从属性(Dependency)：可以让一个操作从属于其他操作。任何操作都可以从属于人以数量的操作。当你让操作A从属于操作B时，即使你调用了才做A的"start"方法，也会等待操作B结束后才开始执行。

例如：

	MyDownloadOperation *downloadOp = [[MyDownloadOperation alloc] init]; // MyDownloadOperation is a subclass of NSOperation

	MyFilterOperation *filterOp = [[MyFilterOperation alloc] init]; // MyFilterOperation  is a subclass of NSOperation
	[filterOp addDependency:downloadOp];

删除依赖关系：[filterOp removeDependency:downloadOp];

2.3.2 优先级(Priority)：可以根据后台运行的操作的重要性设置优先级，通过"setQueuePriority:"方法设置一个操作的优先级。

	[filterOp setQueuePriority:NSOperationQueuePriorityVeryLow];

线程优先级的种类有五种：NSOperationQueuePriorityVeryLow, NSOperationQueuePriorityLow, NSOpertationQueuePriorityNormal, NSOperationQueuePriorityHigh和NSOperationQueuePriorityVeryHigh

当你添加一个操作（线程）到一个队列时，在对操作调用“start”方法之前，NSOperationQueue会浏览所有的操作。那些有较高优先级的操作会被先执行。有同等优先级的操作会按照添加到队列中的顺序去执行（先进先出）。

2.3.3 线程完成操作(completion block)：在NSOperation类中另一个有用的方法叫setCompletionBlock:。如果在操作完成之后你还有一些事情想做，可以把它放在一个块中，并且传递给这个方法。这个块会在主线程中执行。

### 2.4 NSOperationQueue API

2.4.1 初始化
NSOperationQueue使用方法相当简单。它甚至比NSOperation还要简单，因为它不需要用继承实现，或者重写里面的方法。你只需要创建一个实例，给队列起一个名字（以便在运行时可以识别出你的操作队列，并且让调试变得简单）：

	NSOperationQueue *myQueue = [[NSOperationQueue alloc] init];
	myQueue.name = @"Download Queue";

2.4.2 并发管理

队列和线程是两个不同的概念，一个队列可以包含多个线程。每个队列中的操作会在所属的线程中运行。如果你创建一个队列，之后添加三个吃哦啊做到里面。队列会发起三个单独的线程，然后让所有操作在各自的线程中并发运行。

至于有多少个线程会被创建，取决于硬件。默认情况下，NSOperationQueue类会在场景背后加入适配代码，决定如何在特定的平台下运行代码是最好的，并且会尽量启用最大的线程数量。

如果系统是空闲的，并且有很多可用资源，这样NSOperationQueue会启用比如8个同步线程。下次再运行程序，系统正忙于处理其他不相关操作，它们消耗着资源，然后NSOperationQueue只会启用两个同步线程。

2.4.2.1 最大并发量：NSOperation允许你设定最大并发量。NSOperationQueuhi选择去运行任何数量的并发操作，但是不会超过最大值。

	myQueue.MaxConcurrentOperationCount = 3;

如果你改变了主意，想将MaxConcurrentOperationCount设置回默认值，你可以执行下列操作：

	myQueue.MaxConcurrentOperationCount = NSOperationQueueDefaultMaxConcurrentOperationCount;

2.4.2.2 添加操作：一个操作一旦被添加到队列中，就需要传送一个release给操作对象（如果使用手动引用计数，非ARC的话），然后队列会负责开始这个操作。从这点上看，什么时候调用”start“方法由队列说了算。

	[myQueue addOperation:downloadOp];
	[downloadOp release]; // manual reference counting

2.4.2.3 待处理操作：任何时候你可以询问一个队列那个操作在里面，并且总共有多少个操作在里面。只有那些等待被执行的操作，还有那些正在运行的操作会被保留在队列中。操作一旦完成，就会退出队列。

	NSArray *active_and_pending_operations = myQueue.operations;
	NSInteger count_of_operations = myQueue.operationCount;

2.4.2.4 暂停队列：可以通过设定setSuspended:YES来暂停一个队列，这样会暂停所有在队列中的操作 - 你不能单独的暂停操作。要重新开始队列，只要简单的setSuspended:NO。

	// Suspend a queue
	[myQueue setSuspended:YES];
	// Resume a queue
	[myQueue setSuspended:NO];

2.4.2.5 取消操作：取消队列中所有操作，只需要调用“cancelAllOperations”方法即可。上面提到过检查NSOperation中的isCancelled属性，“cancelAllAperations”并没有做太多的工作，它只是对队列中的每一个操作调用“cancel”方法 - 这并没有很大的作用。如果一个操作没有开始，调用它的“cancel”方法，操作会被取消，并从队列中移除。但是，如果一个操作已经在执行，这就要单独的操作去识别撤销（通过检查isCancelled属性）然后停止它的工作。

	[myQueue cancelAllOperations];

2.4.2.6 addOperationWithBlock：如果有一个简单的操作不需要被继承，你可以将它当作一个块（block）传递给队列。如果需要葱块哪里传递回任何数据，记得你不应该传递任何强饮用指针给块；相反，你必须使用若饮用。而且，如果你想要在块中做一些跟UI有关的事情，你必须在主线程中做。

	UIImage *myImage = nil;

	// Create a weak reference
	__weak UIImage *myImage_weak = myImage;

	// Add an operation as a block to a queue
	[myQueue addOperationWithBlock:^{

		// a block of operation
		NSURL *aURL = [NSURL URLWithString:@"http://www.somewhere.com/image.png"];
		NSError = *error = nil;
		NSData *data = [NSData dataWithContentsOfURL:aURL options:nil error:&error];
		if (!error)
			[myImage_weak imageWithData:data];

		// Get hold of main queue (main thread)
		[[NSOperationQueue mainQueue] addOperationWithBlock:^{
			myImageView.image = myImage_weak; // updatting UI
		}];
	}];



3、GCD (Grand Central Dispatch)
-------------------------------

GCD是Apple开发的一个多核编程的解决办法。在iOS4.0开始才能使用。GCD是一个替代NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。它的主要部件是一个FIFO队列和一个线程池，前者用来添加任务，后者用来执行任务。

### 3.1 dispatch queue介绍： dispatch queue分成一下三种：

3.1.1 运行在主线程的Main queue，通过dispatch_get_main_queue获取。调用dispatch_get_main_queue()会返回主队列，也就是UI队列。它一般用于在其他队列中异步完成了一些工作后，需要在UI队列中更新界面的情况。它属于串行队列。

3.1.2 并行队列global diaptch queue，通过dispatch_get_global_queue获取，由系统创建三个不同优先级的dispatch queue。并行队列的执行顺序与其加入队列的顺序相同。其形式为：

dispatch_queue_t dispatch_get_global_queue(long priority, unsigned long flags);

3.1.3 串行队列serial queues一般用于按顺序同步访问，可创建任意数量的串行队列，各个串行队列之间是并发的。

### 3.2 GCD的用法

	// 串行队列的创建
	dispatch_queue_t serialQ = dispatch_queue_create("eg.gcd.serialQueue", DISPATCH_QUEUE_SERIAL); 
	dispatch_async(serialQ, ^{
		// code to be executed
	});
	dispatch_release(serialQ);

	// 并行队列的创建
	dispatch_queue_t concurrentQ = dispatch_queue_create("eg.gcd.ConcurrentQueue", DISPATCH_QUEUE_CONCURRENT);
	dispatch_async(concurrentQ, ^{
		// code to be executed
	});
	dispatch_release(concurrentQ);
	
	dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{      // 后台运行
		// code to be executed
		
		dispatch_async(dispatch_get_main_queue(), ^{ // 主线程运行
			// code to be executed
		});
	});

dispatch_async函数将传入的block块放入指定的queue里运行，这个函数是异步的，这意味着它会理解返回二不管block是否运行结束。因此，我们可以在block里运行各种耗时的操作（如网络请求），而同时不阻塞UI线程。除了异步(async)之外，还有同步(sync)，延时(delay)。

	// 一次性执行
	static dispatch_once_t onceToken
	dispatch_once(&onceToken, ^{
		// code to be executed once
	});

	// 延迟2秒执行
	double delayInSeconds = 2.0;
	dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);
	dispatch_after(popTime, dispatch_get_main_queue(), ^(void) {
		// code to be executed on the main queue after delay
	});

	// 执行某个代码片段若干次
	dispatch_apply(10, globalQ, ^(size_t index) {
		// do sth. 10 times
	});

	// 合并汇总结果
	dispatch_group_t group = dispatch_group_create();
	dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^{
		// 并行执行的线程一
	});
	dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^{
		// 并行执行的线程二
	});
	dispatch_group_notify(group, dispatch_get_global_queue(0, 0), ^{
		// 汇总结果
	});
	dispatch_release(group);

### 3.3 GCD让程序在后台长久运行

在没有使用GCD时，当app被按home键退出后，app仅有最多5秒钟的时间做一些保存或清理资源的工作。但是在使用GCD后，app最多有10分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作。

示例如下：

	// AppDelegate.h文件
	@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundUpdateTask;

	// AppDelegate.m文件
	- (void)applicationDidEnterBackground:(UIApplication *)application
	{
		[self beingBackgroundUpdateTask];
		// 在这里加上你需要长久运行的代码
		[self endBackgroundUpdateTask];
	}

	- (void)beingBackgroundUpdateTask
	{
		self.backgroundUpdateTask = [[UIApplication sharedApplication] beingBackgroundTaskWithExpirationHandler:^{
			[self endBackgroundUpdateTask];
		}];
	}

	- (void)endBackgroundUpdateTask
	{
		[[UIApplication sharedApplication] endBackgroundUpdateTask:self.backgroundUpdateTask];
		self.backgroundUpdateTask = UIBackgroundTaskInvalid;
	}

整理文章来源：
-----------

1.[iOS多线程编程之NSThread的使用](http://blog.csdn.net/totogo2010/article/details/8010231)

2.[如何使用NSOperations和NSOperationQueues](http://www.cocoachina.com/applenews/devnews/2012/1010/4900.html)

3.[iOS多线程编程之Grand Central Dispatch(GCD)介绍和使用](http://blog.csdn.net/onlyou930/article/details/8225853)

4.[iOS多线程GCD](http://www.cnblogs.com/pure/archive/2013/03/31/2977420.html)